#!/usr/bin/env python3
"""Patch/unpatch Codex config.toml notify line for agent-indicator.

Usage:
    codex_config.py patch  <config_toml> <target_dir>
    codex_config.py unpatch <config_toml> [<target_dir>]

patch:  Set notify to agent-indicator's codex-notify.sh. If a non-agent-indicator
        notify already exists, generate a chain wrapper that calls both scripts.
unpatch: Remove agent-indicator from notify. Restore the original script if a
         chain wrapper was in use.
"""

import json
import os
import pathlib
import re
import stat
import sys

CHAIN_SCRIPT_NAME = "codex-notify-chain.sh"
ORIGINAL_MARKER = "# original-notify: "


def parse_notify(text):
    """Return the parsed notify array from config.toml text, or None."""
    m = re.search(r'^notify\s*=\s*(\[.*\])', text, flags=re.MULTILINE)
    if not m:
        return None
    try:
        return json.loads(m.group(1))
    except (json.JSONDecodeError, ValueError):
        return None


def remove_notify_lines(text):
    """Remove all notify = [...] lines from config text."""
    return re.sub(r'^notify\s*=\s*\[.*\]\s*\n?', '', text, flags=re.MULTILINE)


def is_our_script(notify_arr, target_dir):
    """Check if notify array points to our specific install dir."""
    prefix = str(target_dir)
    return any(str(x).startswith(prefix) for x in notify_arr)


def is_chain_wrapper(notify_arr):
    """Check if a notify array references our chain wrapper."""
    return any(CHAIN_SCRIPT_NAME in str(x) for x in notify_arr)


def read_original_from_chain(chain_path):
    """Parse the original-notify comment from a chain wrapper script."""
    try:
        for line in chain_path.read_text(encoding="utf-8").splitlines():
            if line.startswith(ORIGINAL_MARKER):
                return json.loads(line[len(ORIGINAL_MARKER):])
    except Exception:
        pass
    return None


def build_chain_wrapper(original_notify, our_script):
    """Generate the chain wrapper shell script content."""
    original_json = json.dumps(original_notify)
    original_cmd = " ".join(f'"{x}"' for x in original_notify)
    return (
        "#!/usr/bin/env bash\n"
        "# Auto-generated by agent-indicator. Do not edit.\n"
        f"{ORIGINAL_MARKER}{original_json}\n"
        "set -uo pipefail\n"
        f'{original_cmd} "$@" 2>/dev/null || true\n'
        f'exec "{our_script}" "$@"\n'
    )


def write_executable(path, content):
    path.write_text(content, encoding="utf-8")
    path.chmod(path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)


def set_notify(text, notify_value_str):
    """Replace or append notify line, keeping it in the top-level TOML scope."""
    text = remove_notify_lines(text)
    # Insert before the first [section] header to stay at top level
    m = re.search(r'^\[', text, flags=re.MULTILINE)
    if m:
        pos = m.start()
        text = text[:pos] + notify_value_str + "\n" + text[pos:]
    else:
        text = text.rstrip("\n")
        if text:
            text += "\n"
        text += notify_value_str + "\n"
    return text


def patch(config_path, target_dir):
    our_script = str(target_dir / "adapters" / "codex-notify.sh")
    chain_path = target_dir / "adapters" / CHAIN_SCRIPT_NAME

    try:
        text = config_path.read_text(encoding="utf-8")
    except FileNotFoundError:
        text = ""

    existing = parse_notify(text)
    original = None

    if existing and is_chain_wrapper(existing):
        original = read_original_from_chain(chain_path)
    elif existing and not is_our_script(existing, target_dir):
        original = existing

    if original:
        wrapper = build_chain_wrapper(original, our_script)
        write_executable(chain_path, wrapper)
        notify_line = f'notify = ["{chain_path}"]'
    else:
        notify_line = f'notify = ["{our_script}"]'
        if chain_path.exists():
            chain_path.unlink()

    new_text = set_notify(text, notify_line)
    config_path.write_text(new_text, encoding="utf-8")


def unpatch(config_path, target_dir=None):
    try:
        text = config_path.read_text(encoding="utf-8")
    except FileNotFoundError:
        return

    existing = parse_notify(text)
    if not existing:
        return

    chain_path = None
    if target_dir:
        chain_path = target_dir / "adapters" / CHAIN_SCRIPT_NAME

    original = None
    if chain_path and is_chain_wrapper(existing):
        original = read_original_from_chain(chain_path)

    is_ours = target_dir and is_our_script(existing, target_dir)
    if not is_ours and not is_chain_wrapper(existing):
        return

    new_text = remove_notify_lines(text)

    if original:
        original_json = json.dumps(original)
        notify_line = f"notify = {original_json}"
        new_text = new_text.rstrip("\n")
        if new_text:
            new_text += "\n"
        new_text += notify_line + "\n"

    if new_text != text:
        config_path.write_text(new_text, encoding="utf-8")

    if chain_path and chain_path.exists():
        chain_path.unlink()


def main():
    if len(sys.argv) < 3:
        print(__doc__, file=sys.stderr)
        sys.exit(1)

    cmd = sys.argv[1]
    config_path = pathlib.Path(sys.argv[2])

    if cmd == "patch":
        if len(sys.argv) < 4:
            print("patch requires <config_toml> <target_dir>", file=sys.stderr)
            sys.exit(1)
        target_dir = pathlib.Path(sys.argv[3])
        patch(config_path, target_dir)
    elif cmd == "unpatch":
        target_dir = pathlib.Path(sys.argv[3]) if len(sys.argv) > 3 else None
        unpatch(config_path, target_dir)
    else:
        print(f"Unknown command: {cmd}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
